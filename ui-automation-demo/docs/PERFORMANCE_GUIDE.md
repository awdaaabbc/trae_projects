# Midscene 测试用例性能优化指南

## 核心问题
Midscene 是基于大模型 (LLM) 的自动化框架。与传统基于规则（如 `id=btn_submit`）的框架不同，它的每一步操作都包含一次“**云端推理**”过程。

**时间成本公式**：
`总耗时 ≈ 步骤数量 × (截图上传时间 + LLM推理时间[约3s] + 动作执行时间)`

因此，**减少步骤数量**是提升速度的关键。

## 优化策略：指令合并 (Instruction Merging)

### 🔴 慢速写法 (Step-by-Step)
这种写法符合人类直觉，但对 AI 来说效率极低。每一步都要重新截图、上传、推理。

```json
[
  { "action": "点击搜索框" },      // 推理 3s
  { "action": "输入 'iPhone'" },   // 推理 3s
  { "action": "点击搜索按钮" },    // 推理 3s
  { "action": "等待结果加载" }     // 推理 3s
]
// 总计：12s+
```

### 🟢 高速写法 (Merged)
利用 LLM 的规划能力，将连续的交互合并。

```json
[
  { "action": "点击搜索框，输入 'iPhone'，然后点击搜索按钮" }, // 推理 3s，执行 3 个动作
  { "action": "等待结果加载" }
]
// 总计：6s+ (速度提升 50%!)
```

## 其他优化技巧

### 1. 减少显式断言 (Implicit Assertion)
Midscene 的 `aiAct` 自带成功检测。如果找不到元素它会报错。
**不要写**：`assert: 检查搜索框是否存在` -> `action: 点击搜索框`
**直接写**：`action: 点击搜索框` (如果不存在，这一步自然会挂)

### 2. 使用原生坐标滚动 (如果可能)
在 Android 上，使用 `scroll down` 指令 Midscene 可能会调用底层原生滚动，这比 AI 视觉分析滚动要快得多。我们在代码层已经做了优化，优先拦截 `scroll` 关键字走原生通道。

### 3. 开启缓存 (仅调试期)
在 `.env` 中设置 `MIDSCENE_CACHE=true`。这会缓存推理结果，对于 UI 没变的重复执行，速度是毫秒级的。

## 总结
**“少即是多”**。把 AI 当作一个聪明但反应慢的助手，一次性把话说完，而不是一句一句崩。
